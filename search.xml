<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>哲學系發癲</title>
    <url>/%E5%93%B2%E5%AD%B8%E7%B3%BB%E7%99%BC%E7%99%B2/</url>
    <content><![CDATA[<p>原來我開的笑話都指向空虛的所指<br>我還以為你是一個真實他者<br>沒想到是個大他者<br>我的能指只是傳達了純粹意識形態<br>我們的關係之間連一場遊戲都玩不成</p>
<span id="more"></span>

<p><img data-src="/%E5%93%B2%E5%AD%B8%E7%B3%BB%E7%99%BC%E7%99%B2/tien.jpg"></p>
]]></content>
      <categories>
        <category>日常廢文</category>
      </categories>
      <tags>
        <tag>哲學</tag>
      </tags>
  </entry>
  <entry>
    <title>【B級調酒EP1】</title>
    <url>/%E3%80%90B%E7%B4%9A%E8%AA%BF%E9%85%92EP1%E3%80%91/</url>
    <content><![CDATA[<p>覺旅咖啡英式午餐茶+蘇格蘭威士忌 </p>
<p>酒譜<br>520ml紅茶<br>15ml 威士忌</p>
<span id="more"></span>
<h3 id="短評"><a href="#短評" class="headerlink" title="短評"></a>短評</h3><p>大概連ddffg都喝不下去</p>
<p><img data-src="/%E3%80%90B%E7%B4%9A%E8%AA%BF%E9%85%92EP1%E3%80%91/grose.png"></p>
]]></content>
      <categories>
        <category>飲食</category>
        <category>酒</category>
      </categories>
      <tags>
        <tag>調酒</tag>
        <tag>酒譜</tag>
        <tag>土製</tag>
      </tags>
  </entry>
  <entry>
    <title> 爬蟲基礎入門: Beautiful Soup</title>
    <url>/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Beautiful-Soup/</url>
    <content><![CDATA[<h3 id="什麼是BeautifulSoup"><a href="#什麼是BeautifulSoup" class="headerlink" title="什麼是BeautifulSoup?"></a>什麼是BeautifulSoup?</h3><p>BeautifulSoup，又名美麗的湯，就如同魯迅所說過的，吃日料要喝味噌湯，到台南要喝牛肉湯，爬蟲的話就要用美麗的湯。(誤<br>BeautifulSoup4我們一般簡稱BS4，是用來做網站的html架構解析，如同前面所講的，html碼是以多層標籤作為架構，也因此我們可以利用BS4這個套件來建立其專屬class BeautifulSoup底下的物件，其就包含了原網站html碼的相關結構，像是標籤的父子、兄弟關係，更可以利用其中的搜尋功能找尋標籤名稱、內容或屬性，進而定位到我們感興趣的位置。</p>
<span id="more"></span>

<p>在經過基本的pip install後，我們就可以引入bs4了。<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Beautiful-Soup/20152706UAEuGzKBvW.png"></p>
<p>之後我們就能像這樣，引入網址後，利用基本request取得html源碼，再利用BS4進行基本解析，建立出soup_m1的物件，之後便可以利用BS4的函式對其定位、分析。<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Beautiful-Soup/20152706L0rBAzgmoz.png"></p>
<h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>昨天出現的這句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">soup_m1 = BeautifulSoup(html_m1.text, &quot;html.parser&quot;)</span><br></pre></td></tr></table></figure>
<p>其中的<code>html.parser</code>便是使用的解析器，是python內建的。<br>除了這個外還能用html5lib和lxml但我也沒用過，詳細優缺點可能要google下。<br>哪天有試了再補充上來吧</p>
<h3 id="解析方法"><a href="#解析方法" class="headerlink" title="解析方法"></a>解析方法</h3><p>比較常用到的是find()、find_all()和select()。</p>
<ul>
<li><p>find()、find_all()<br>兩個都是使用html的標籤進行搜尋的。<br>而這兩者的差別是find()只會回傳第一個符合的結果，find_all()則會回傳所有符合的結果</p>
</li>
<li><p>select()<br>使用CSS選擇器(CSS selectors)來進行搜尋。<br>CSS之前沒有提到，主要是用來把網站上色的。<br>其中會用到選擇器來指定特定範圍的HTML進行操作。<br>select()便是利用這東西的語法來爬的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>程式</category>
        <category>爬蟲</category>
      </categories>
      <tags>
        <tag>爬蟲</tag>
        <tag>程式</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title> 爬蟲基礎入門: Requests</title>
    <url>/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Requests/</url>
    <content><![CDATA[<p>本系列預設各位擁有基本的python能力，對各種資料結構、套件、模組等有一定概念就行了。<br>本文的範例都是在python 3.10下操作的。</p>
<h3 id="requests是什麼"><a href="#requests是什麼" class="headerlink" title="requests是什麼?"></a>requests是什麼?</h3><p>簡單來說就是能讓你抓取整個網頁的東西，也能夠丟上去一些東西。<br>比較常用到的有下列功能。</p>
<ul>
<li>get</li>
<li>post</li>
<li>session</li>
</ul>
<span id="more"></span>

<p>python預設並沒有安裝，所以要先用pip安裝下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<p>安裝完後在寫程式前也記得先import</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>基本上就是抓下網頁。在抓取網頁時加上昨天提到的header比較不會被擋下來。</p>
<p>舉例來說:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">	&#x27;Users-agent&#x27;: &#x27;Mozilla/5.0 (X11; Ubuntu; Linux x86 64; rv:91.0) Gecko/20100101 Firefox/91.0&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">url = &#x27;你想爬的網站&#x27;</span><br><span class="line">r = requests.get(url, headers = headers)</span><br><span class="line"></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<p>上述的程式應該會把網頁的html印在終端機，<br>可以填入各種網址試試看這樣的程式會印出什麼。<br>當然單純只做這樣被擋下來而只會顯示<code>respone&lt;XXX&gt;</code>的機率也不低就是。<br>也可以試試看換個header看網頁會不會有差異。</p>
<p>總之抓下來的單純html當然是沒什麼用，要解析html並取出其中有用的資訊的話就要靠後面幾天會提到的bs4跟lxml了。</p>
<h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><p>能夠丟字串或json檔上去，在需要給網站資訊時會用到。<br>舉例來說，投票機器人。<br>但一時之間想不到什麼很好的網站舉例。</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>能夠在多個請求中保持一些數據。<br>如果網站會用到cookie的話就需要使用這個。</p>
<p>舉例來說你用session登入一個網站後，之後在用這個物件抓取該網站其他頁面也會默認你是登入的。<br>但一時之間想不到什麼很好的網站舉例。</p>
]]></content>
      <categories>
        <category>程式</category>
        <category>爬蟲</category>
      </categories>
      <tags>
        <tag>爬蟲</tag>
        <tag>程式</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title> 爬蟲基礎入門: robots.txt &amp; header</title>
    <url>/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-robots-txt-header/</url>
    <content><![CDATA[<p>今天要來介紹當我們在爬蟲前，應該要知道的一些技巧與規範</p>
<hr>
<h3 id="為甚麼需要知道這些爬蟲規範？"><a href="#為甚麼需要知道這些爬蟲規範？" class="headerlink" title="為甚麼需要知道這些爬蟲規範？"></a>為甚麼需要知道這些爬蟲規範？</h3><p>首先，我們必須知道過度的網路爬蟲可能是違法的，<br>如使用多執行緒進行對網站的大量拜訪，在沒有適當的存取時間間隔下，可能會造成一般人熟知的<strong>DDOS</strong>(Denial-Of-Service Attack)，進而造成其他使用者無法拜訪、甚至是主機癱瘓。<br>因此，某些網站有制定所謂的「規範」，讓爬蟲使用者能夠去遵守並避免存取到private data</p>
<span id="more"></span>
<p>請注意這項規範並不具有強制力，並無法阻擋真正有心攻擊的爬蟲程式。</p>
<h3 id="「規範」—-robots-txt"><a href="#「規範」—-robots-txt" class="headerlink" title="「規範」— robots.txt"></a>「規範」— robots.txt</h3><p>robots.txt是一個告訴爬蟲哪些內容是否可存取的文字檔。<br>這項檔案通常位於網頁根目錄下的robots.txt，<br>換句話說，在main-page下加個&#x2F;robots.txt就能檢視。</p>
<p>舉個例子吧，我們先進到<a href="http://google.com/">google</a>的首頁</p>
<p><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-robots-txt-header/20152706kiMp9LoNrj.png"></p>
<p>相當正常，不是嗎?<br>再來利用上面的方法去找robots.txt，<br>我們接著在.com後面接著&#x2F;robots.txt，<br>使網址成為<a href="https://www.google.com/robots.txt">https://www.google.com/robots.txt</a></p>
<p><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-robots-txt-header/20152706qRcQSJ2ABd.png"></p>
<p>成功了！<br>可是密密麻麻的，打這麼多字誰他媽看得完?<br>但事實上，這份文字檔可以被拆分成幾個部分，<br>我們從第一行開始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. User-Agent: *</span><br></pre></td></tr></table></figure>
<p>User-Agent這一欄代表的是允許的爬蟲類型，而 <strong>*</strong> 則代表<strong>所有</strong>的意思，<br>所以第一行可以被解讀成，允許所有爬蟲拜訪。<br>此外有一些特別的程式只允許特定爬蟲拜訪網頁，如Googlebot、Applebot等，<br>如在最後幾行處，可以看到google的網頁允許Twitterbot能夠比一般使用者額外拜訪&#x2F;imgres的子目錄。</p>
<p>再來我們繼續往下探討，大致上可以分為<strong>Allow</strong>開頭的，以及<strong>Disallow</strong>開頭的句子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. Disallow: /search</span><br></pre></td></tr></table></figure>
<p>這句話代表著，拒絕網路爬蟲訪問search子目錄以及其子目錄下所有目錄，<br>而接下來的第三行，你們應該也就猜的到意思了，就是允許拜訪冒號後面的子目錄。</p>
<h3 id="表頭headers"><a href="#表頭headers" class="headerlink" title="表頭headers"></a>表頭headers</h3><p>headers是對client端向server發出請求時的敘述資訊。<br>有一些網站會針對網路爬蟲進行阻擋，其中一項阻擋的手法就是針對headers，<br>當網頁收到非瀏覽器的headers發出的請求時，網頁就拒絕client的存取。</p>
<p>解決手段非常的簡單粗暴，既然你拒絕非瀏覽器外的訪問，那我就成為瀏覽器就好了啊!?<br>那我們要怎麼成為瀏覽器呢?<br>這樣推薦一個作法：</p>
<ul>
<li>開啟Chrome時按下F12鍵後，先按F5使其重整載入資源，點選其中一項被載入的資源，點選Network欄中的Header，複製其中的Uger-Agent</li>
</ul>
<p>如此一來就得到瀏覽器的header，將自己偽裝成瀏覽器了。<br>下一章在requests時，我們會介紹在requests.get()中可以帶入header參數，<br>在header參數中帶入我們剛剛取得的瀏覽器header，我們就可以成功偽裝了。</p>
]]></content>
      <categories>
        <category>程式</category>
        <category>爬蟲</category>
      </categories>
      <tags>
        <tag>爬蟲</tag>
        <tag>程式</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Discord Bot-Cogs</title>
    <url>/Discord-Bot-Cogs/</url>
    <content><![CDATA[<p>如果你的機器人功能多到一個程度，把全部的程式碼全部塞在一個文件裡顯然不是好辦法。<br>不但看起來雜亂，也難以維護，就算只是其中一個功能出問題也必須要把整個bot關掉。<br>這時候就可以使用<strong>Cogs</strong>的架構來寫，<br>可以將commands和listener等東西分堆塞在各自文件裡並方便我們裝卸。</p>
<span id="more"></span>
<p>照<a href="https://discordpy.readthedocs.io/en/stable/ext/commands/cogs.html">官方文件</a>的說法，比較重要的有這幾點:</p>
<ul>
<li>每個cogs都是<code>commands.Cog</code>的子類別</li>
<li>每個command要前加<code>@commands.command()</code></li>
<li>每個listener要前加<code>@commands.Cog.listener()</code></li>
<li>Cogs可以用<code>Bot.add_cog()</code>來註冊</li>
<li>Cogs可以用<code>Bot.remove_cog()</code>來卸載</li>
<li>通常會跟<a href="https://discordpy.readthedocs.io/en/stable/ext/commands/extensions.html#ext-commands-extensions">Extension</a>功能配合</li>
</ul>
<p>當然單純這樣條列出來是看不懂的，底下來看實例。<br>其檔案架構通常會長下面這樣<br><img data-src="/Discord-Bot-Cogs/20152706EJhEPhiYQA.png"></p>
<p>cogs資料夾是拿來放各個cogs的<br>core資料夾是拿來放一些你cogs可能會常用到的函數。<br>main.py是拿來運行的檔案，裡面也包含了載入和裝卸cogs的程式碼，會長的類似下面這樣:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from discord.ext import commands</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">bot = commands.Bot(&#x27;prefix&#x27;)</span><br><span class="line"></span><br><span class="line">#下面這塊從cogs資料夾中取出所有.py結尾的檔案並用load_extension載入cogs</span><br><span class="line">for filename in os.listdir(&#x27;./cogs&#x27;):</span><br><span class="line">	if filename.endswith(&#x27;.py&#x27;):</span><br><span class="line">		bot.load_extension(f&#x27;cogs.&#123;filename[:-3]&#125;&#x27;) </span><br><span class="line"></span><br><span class="line">@bot.event</span><br><span class="line">async def on_ready():</span><br><span class="line">	print(&#x27;Test begin...&#x27;) </span><br><span class="line">	</span><br><span class="line">#這裡建個指令讓你可以載入Cog</span><br><span class="line">@bot.command()</span><br><span class="line">async def load(ctx, cog_name):</span><br><span class="line">	try:</span><br><span class="line">		bot.load_extension(f&#x27;cogs.&#123;cog_name&#125;&#x27;)</span><br><span class="line">	except:</span><br><span class="line">		await ctx.send(&#x27;Failed.&#x27;)</span><br><span class="line">		return</span><br><span class="line">	await ctx.send(&#x27;load success!&#x27;)</span><br><span class="line"></span><br><span class="line">#這裡建個指令讓你可以卸載Cog</span><br><span class="line">@bot.command()</span><br><span class="line">async def unload(ctx, cog_name):</span><br><span class="line">	try:</span><br><span class="line">		bot.unload_extension(f&#x27;cogs.&#123;cog_name&#125;&#x27;)</span><br><span class="line">	except:</span><br><span class="line">		await ctx.send(&#x27;Failed.&#x27;)</span><br><span class="line">		return</span><br><span class="line">	await ctx.send(&#x27;unload success!&#x27;)</span><br><span class="line"></span><br><span class="line">#這裡建個指令讓你可以重新載入Cog</span><br><span class="line">@bot.command()</span><br><span class="line">async def reload(ctx, cog_name):</span><br><span class="line">	try:</span><br><span class="line">		bot.reload_extension(f&#x27;cogs.&#123;cog_name&#125;&#x27;)</span><br><span class="line">	except:</span><br><span class="line">		await ctx.send(&#x27;Failed.&#x27;)</span><br><span class="line">		return</span><br><span class="line">	await ctx.send(&#x27;reload success!&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">	bot.run(&#x27;TOKEN&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>接著在core底下加一個文檔，這裡我叫他init.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import discord</span><br><span class="line">from discord.ext import commands</span><br><span class="line"></span><br><span class="line">class Cog_Extension(commands.Cog):</span><br><span class="line">	def __init__(self, bot):</span><br><span class="line">		self.bot = bot</span><br></pre></td></tr></table></figure>


<p>接著來把一個指令用成cogs。<br>就拿上篇那個<a href="https://ithelp.ithome.com.tw/articles/10306205">请不要随意地触碰我！ 十分感谢！</a>來舉例<br>他原本的程式區塊大概長這樣:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@bot.command(aliases=[&#x27;touch&#x27;])</span><br><span class="line">async def t(message):</span><br><span class="line">	await message.channel.send(&#x27;请不要随意地触碰我！ 十分感谢！&#x27;)</span><br></pre></td></tr></table></figure>

<p>把他用成cogs的話會需要把它塞進Class並加上我們剛剛寫的東西，所以會長得像這樣</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from discord.ext import commands</span><br><span class="line">from core.init import Cog_Extension</span><br><span class="line"></span><br><span class="line">class touch(Cog_Extension):        #建議class名稱跟檔案名稱一樣</span><br><span class="line">@commands.command(aliases=[&#x27;touch&#x27;])    </span><br><span class="line">	async def t(self, message):    #記得在參數列最前面加上self</span><br><span class="line">		await message.channel.send(&#x27;请不要随意地触碰我！ 十分感谢！&#x27;)</span><br></pre></td></tr></table></figure>
<p>記得要import需要的套件</p>
<p>接著在下面加上setup的函數</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from discord.ext import commands</span><br><span class="line">from core.init import Cog_Extension</span><br><span class="line"></span><br><span class="line">class touch(Cog_Extension):</span><br><span class="line">	@commands.command(aliases=[&#x27;touch&#x27;])</span><br><span class="line">	async def t(self, message):</span><br><span class="line">		await message.channel.send(&#x27;请不要随意地触碰我！ 十分感谢！&#x27;)</span><br><span class="line"></span><br><span class="line">def setup(bot):</span><br><span class="line">	bot.add_cog(touch(bot))</span><br><span class="line">#這裡的bot.add_cog(touch(bot))中的(bot)前面填上你class的名子</span><br></pre></td></tr></table></figure>

<p>這樣運行後給機器人預設的help指令後就能看到結構了。<br><img data-src="/Discord-Bot-Cogs/20152706dMFbDgmc8p.png"></p>
<p>像這邊unload掉touch後可以發現輸t他也沒反應了，輸help也看不見了。<br><img data-src="/Discord-Bot-Cogs/20152706NNRA2I8xr8.png"></p>
<p>而load回來的話可以發現指令有反應了，help中也看的到了。<br><img data-src="/Discord-Bot-Cogs/20152706uqPycyubVO.png"></p>
<hr>
<p>前述的的程式結構較簡單可能沒什麼感覺，但要是程式複雜到如下圖能夠先unload一塊調整完後再load回去還是挺方便的。<br><img data-src="/Discord-Bot-Cogs/20152706kGyb4P4XHd.png"></p>
]]></content>
      <categories>
        <category>程式</category>
        <category>Discord bot</category>
      </categories>
      <tags>
        <tag>程式</tag>
        <tag>python</tag>
        <tag>Discord</tag>
      </tags>
  </entry>
  <entry>
    <title>Discord Bot-創建一隻bot</title>
    <url>/Discord-Bot-%E5%89%B5%E5%BB%BA%E4%B8%80%E9%9A%BBbot/</url>
    <content><![CDATA[<p>Discord是一個方便的通訊軟體，而他比起一般通訊軟體的優勢就是便利的語音以及多功能的群組(內稱伺服器)，甚至伺服器內部還可以再分為多個子頻道，提供主題分類，也可以加入自訂的機器人，增添更多的變化。</p>
<span id="more"></span>
<p><img data-src="/Discord-Bot-%E5%89%B5%E5%BB%BA%E4%B8%80%E9%9A%BBbot/20152706MBGmHIhGdS.png"><br>大概就像這樣，其中左上角的test2就是整個伺服器(guild、server)的名稱，左邊那排則是這個伺服器所有的文字頻道和語音頻道(channel)，中間則是文字訊息內容，而rever chan則是我自己加進來的機器人。</p>
<p>那麼，在新增機器人之前，我們必須要先取得創建機器人專案，並取得他的token。<br>首先，我們先進入dc developer的網頁，並登入dc帳號後，點選右上角的new application。<br><img data-src="/Discord-Bot-%E5%89%B5%E5%BB%BA%E4%B8%80%E9%9A%BBbot/20152706uRtcasLHmn.png"><br>取名並創建完成後，進到該application並且選擇左邊的bot項目，接著點選add bot，新增一個新的機器人。<br><img data-src="/Discord-Bot-%E5%89%B5%E5%BB%BA%E4%B8%80%E9%9A%BBbot/20152706cOtUkl6jZV.png"><br>在dc bot的編寫中，我們是撰寫dc bot的主要內容，而後在程式中填寫要啟用的bot的token，就可以為持有該token的bot加載程式內容，而適用範圍為所有有把該bot拉為成員的server，意即只要伺服器有把bot拉進去，那個server裡的bot就會加載此程式內容。<br><img data-src="/Discord-Bot-%E5%89%B5%E5%BB%BA%E4%B8%80%E9%9A%BBbot/20152706nF0OR14070.png"><br>那麼我們這邊就要點選reset token，取得bot的新token。<br>這邊要注意的是，bot的token絕對不行外流，否則容易被有心人士利用加載其他程式內容，可能你隔半小時回來就發現你的伺服器已經被自己的bot洗版各種釣魚連結了。</p>
]]></content>
      <categories>
        <category>程式</category>
        <category>Discord bot</category>
      </categories>
      <tags>
        <tag>程式</tag>
        <tag>python</tag>
        <tag>Discord</tag>
      </tags>
  </entry>
  <entry>
    <title>Discord Bot-基本架構</title>
    <url>/Discord-Bot-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%A7%8B/</url>
    <content><![CDATA[<p>首先先用一個最基本的機器人來示範。請打開一個python檔並鍵入以下內容:</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from discord.ext import commands</span><br><span class="line"></span><br><span class="line">bot = commands.Bot(&#x27;%&#x27;)</span><br><span class="line"></span><br><span class="line">@bot.event</span><br><span class="line">async def on_ready():</span><br><span class="line">	print(&#x27;不客气！&#x27;)</span><br><span class="line">	print(&#x27;感谢您使用Discord产品, 欢迎您继续咨询Discord社区！&#x27;)</span><br><span class="line">	</span><br><span class="line">@bot.command(aliases=[&#x27;touch&#x27;])</span><br><span class="line">async def t(message):</span><br><span class="line">	await message.channel.send(&#x27;请不要随意地触碰我！ 十分感谢！&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">	bot.run(&#x27;在這裡輸入您的token&#x27;)</span><br></pre></td></tr></table></figure>

<p>接下來分行解釋下。</p>
<h3 id="bot-commands-bot-‘-’"><a href="#bot-commands-bot-‘-’" class="headerlink" title="bot &#x3D; commands.bot(‘%’)"></a>bot &#x3D; commands.bot(‘%’)</h3><p>造出一個bot的物件。而那個<code>&#39;%&#39;</code>就是呼叫機器人的前綴。<br>不一定要一個字，你要拿<code>&#39;peko&#39;</code>當前綴也是完全可以的。</p>
<p>小補充，如果你也想要用標記機器人來呼叫機器人的話可以這樣寫:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bot = commands.bot(commands.when_mentioned_or(&#x27;%&#x27;))</span><br></pre></td></tr></table></figure>
<p>效果會像這樣:<br><img data-src="/Discord-Bot-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%A7%8B/20152706nEGgzYWzSc.png"></p>
<p>bot裡面詳細有什麼功能可以看一下<a href="https://discordpy.readthedocs.io/en/stable/ext/commands/api.html#bots">官方API的文件</a><br>看不懂也沒關係，後面會帶到一些常見的用法。</p>
<h3 id="bot-event"><a href="#bot-event" class="headerlink" title="@bot.event"></a>@bot.event</h3><p>這個<code>@</code>叫<strong>decorator</strong>，是python的語法糖。<br>簡單來說這東西會把下面的函數丟到你@的函數裡面加工，詳細可以看一下<a href="https://medium.com/citycoddee/python%E9%80%B2%E9%9A%8E%E6%8A%80%E5%B7%A7-3-%E7%A5%9E%E5%A5%87%E5%8F%88%E7%BE%8E%E5%A5%BD%E7%9A%84-decorator-%E5%97%B7%E5%97%9A-6559edc87bc0">這篇</a>。<br>官方API的解釋則在<a href="https://discordpy.readthedocs.io/en/stable/ext/commands/api.html#decorators">這裡</a>。</p>
<p>看不懂也沒什麼關係，就當作一種固定語法。記得在你寫的函數前面加上對應的decorator就行。<br>像這邊就是因為要使用底下的<code>on_ready()</code>所以才會在上面加@bot.event的，可以看下<a href="https://discordpy.readthedocs.io/en/stable/ext/commands/api.html#discord.ext.commands.Bot.event">官方API</a></p>
<p>另外如果點進去官方API的話可以發現他的例子是加了<code>@client.event</code>。<br>使用<code>discord.clinet</code>是另一種Discord機器人的寫法，client的語法基本上把<code>client</code>代換成<code>bot</code>都可用。<br>不過bot(<code>discord.ext.commands.Bot</code>)似乎功能比較多一點加上兩者不能混用所以我都用bot寫。<br>一言以蔽之，看到範例是用<code>clinet</code>就換成<code>bot</code>試試看吧。</p>
<h3 id="async-def-on-ready"><a href="#async-def-on-ready" class="headerlink" title="async def on_ready():"></a>async def on_ready():</h3><p>這邊的<code>async</code>和<code>await</code>是python異步執行套件<code>asyncio</code>的語法。</p>
<p>不過這邊難的地方都寫在discord套件底層了，<br>所以我們只要記得在函數前面加async跟在discord提供的方法前加await就行。</p>
<p><code>on_ready()</code>這個方法，其功能是在機器人上線的那刻執行下列內容。<br>所以如果機器人成功運行了可以看到命令列有以下的輸出。<br><img data-src="/Discord-Bot-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%A7%8B/20152706Sv659LuuVk.png"><br>這樣可以方便我們確定機器人是不是正常上線了。</p>
<h3 id="bot-command-aliases-‘touch’"><a href="#bot-command-aliases-‘touch’" class="headerlink" title="@bot.command(aliases&#x3D;[‘touch’])"></a>@bot.command(aliases&#x3D;[‘touch’])</h3><p><code>@bot.command()</code>這個語法糖可以將下面的函數變成我們在頻道可以使用的指令。<br>預設指令名稱就是下面的函數名。以這個例子來說就是t</p>
<p>括號中間的<code>aliases=[&#39;touch&#39;]</code>則是為這個函數添加更多指令名的。<br>所以結合我們在上面的<code>bot = commands.bot(&#39;%&#39;)</code>設定的前綴，<br>機器人上線後我們用<code>%touch</code>和<code>%t</code>都可以叫出一樣的指令。</p>
<h3 id="async-def-t-message"><a href="#async-def-t-message" class="headerlink" title="async def t(message):"></a>async def t(message):</h3><p>如上所述，函數名就是你在頻道打的指令名。</p>
<p>括號裡面的message基本上就是你在discord發的訊息。<br>但他不僅僅是文字，而是discord api一個’Message’類別的物件。</p>
<p>裡面的功能相當的豐富，可以從中取出相當多的資訊，下面會做說明。</p>
<h3 id="await-message-channel-send-‘请不要随意地触碰我！-十分感谢！’"><a href="#await-message-channel-send-‘请不要随意地触碰我！-十分感谢！’" class="headerlink" title="await message.channel.send(‘请不要随意地触碰我！ 十分感谢！’)"></a>await message.channel.send(‘请不要随意地触碰我！ 十分感谢！’)</h3><p>像這邊我們就從中取出了你發送指令的頻道並在那頻道發送了訊息。<br>具體而言看起來像這樣。<br><img data-src="/Discord-Bot-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%A7%8B/20152706UMjauH0ZsL.png"></p>
<p>其他更多的用法一樣可以詳閱<a href="https://discordpy.readthedocs.io/en/stable/api.html#discord.Message">官方API的公開說明書</a></p>
<h3 id="if-name-“-main-“"><a href="#if-name-“-main-“" class="headerlink" title="if __name__ &#x3D;&#x3D; “__main__“:"></a>if __name__ &#x3D;&#x3D; “__main__“:</h3><p>這行就是確保你是直接執行了這檔案才會跑以下的指令。<br>bot.run()的括號中間輸入您昨天取得的token碼。</p>
<hr>
<p>接著就讓機器人上線並邀請你的機器人進自己的伺服器來玩玩吧。<br>也可以試著改一些設定，或甚至嘗試一些你在官方API找到的功能。<br>看不太懂上面和官方API到底在講什麼鬼的也沒關係，後面跟著做就會漸漸熟悉了。</p>
]]></content>
      <categories>
        <category>程式</category>
        <category>Discord bot</category>
      </categories>
      <tags>
        <tag>程式</tag>
        <tag>python</tag>
        <tag>Discord</tag>
      </tags>
  </entry>
  <entry>
    <title>最近的夜晚</title>
    <url>/%E6%9C%80%E8%BF%91%E7%9A%84%E5%A4%9C%E6%99%9A/</url>
    <content><![CDATA[<p>最近晚上一直都是喝著gin fizz渡過的<br>琴酒+檸檬+糖漿攪拌或搖晃<br>最後加入氣泡水<br>清爽的口感加上琴酒的藥草香以及檸檬的酸和糖漿的甜<span id="more"></span><br>最後加入氣泡水增添的口感<br>同時也有效將琴酒的口味分層<br>不由得一杯接著一杯</p>
<p>建議用可林杯與長冰調配<br>克林杯放入長冰冰杯<br>倒出融水後<br>將琴酒、半顆檸檬的檸檬汁、與糖漿倒入<br>攪拌均勻<br>隨後用氣泡水填滿<br>若剩下半顆檸檬<br>可切一片放杯緣<br>如此一來你便完成了一杯gin fizz</p>
<p>如果想要提升味覺感受<br>可以從琴酒以及氣泡水下手</p>
<p>最後<br>以上言論不代表本人立場</p>
<p><em><strong>好吃到Xin chào&trade;</strong></em><br><strong>筆者：蔡銘揚</strong></p>
]]></content>
      <categories>
        <category>飲食</category>
        <category>酒</category>
      </categories>
      <tags>
        <tag>調酒</tag>
        <tag>酒譜</tag>
        <tag>自製</tag>
      </tags>
  </entry>
  <entry>
    <title>清蒸鱸魚食譜</title>
    <url>/%E6%B8%85%E8%92%B8%E9%B1%B8%E9%AD%9A%E9%A3%9F%E8%AD%9C/</url>
    <content><![CDATA[<h3 id="所需材料："><a href="#所需材料：" class="headerlink" title="所需材料："></a>所需材料：</h3><ul>
<li>鱸魚一尾</li>
<li>檸檬一顆</li>
<li>辣椒兩根</li>
<li>蒜頭三到五瓣<span id="more"></span></li>
<li>蔥一枝</li>
<li>洋蔥一顆</li>
<li>豆芽菜一包</li>
<li>糖</li>
<li>白胡椒粉</li>
<li>米酒</li>
<li>水</li>
<li>魚露</li>
</ul>
<h3 id="魚的處理："><a href="#魚的處理：" class="headerlink" title="魚的處理："></a>魚的處理：</h3><p>1.刮除鱗片、修魚鰭<br>2.剪開魚腹、刮除內臟並清洗乾淨<br>3.確認魚的乾淨並在表面劃刀痕<br>4.將洋蔥及豆芽菜洗淨<br>5.洋蔥切條與豆芽並行鋪於盤底<br><img data-src="/%E6%B8%85%E8%92%B8%E9%B1%B8%E9%AD%9A%E9%A3%9F%E8%AD%9C/FISH.jpg" alt="處理完的魚和醬汁"></p>
<h3 id="調料的處理："><a href="#調料的處理：" class="headerlink" title="調料的處理："></a>調料的處理：</h3><p>6.蒜頭、辣椒切碎<br>7.加入糖一匙<br>8.加入米酒兩匙<br>9.魚露兩匙<br>10.檸檬汁一顆的量<br>11.白胡椒粉一小匙<br>12.加入兩匙水、拌勻<br>13.將魚放入盤內、平均淋上調料<br>14.放入電鍋蒸<br>15.蔥切細絲放上出鍋後的料理<br>16.熱少許油至些許冒煙、淋上蔥絲即可出菜</p>
<p><em><strong>好吃到Xin chào&trade;</strong></em><br><strong>筆者：蔡銘揚</strong></p>
]]></content>
      <categories>
        <category>飲食</category>
        <category>食譜</category>
      </categories>
      <tags>
        <tag>自製</tag>
        <tag>食譜</tag>
      </tags>
  </entry>
  <entry>
    <title>爬蟲基礎入門-JSON</title>
    <url>/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-JSON/</url>
    <content><![CDATA[<p>Json又名為JavaScript Object Notation，一般應用在資料傳輸上，其實Json並不複雜，簡單來說，我們可以把它當作成是一種資料撰寫儲存的格式，就像這樣：</p>
<p><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-JSON/20152706kAFVfBtVRV.png" alt="20152706kAFVfBtVRV.png"><br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-JSON/20152706j6dhBN2Goo.png" alt="20152706j6dhBN2Goo.png"></p>
<span id="more"></span>

<p>上圖是我平常dc群組裡所有的表情符號，將其抓下來後以json的格式儲存，以便之後查詢利用。另外，我們在爬蟲時也經常看到json，像是有時候在網站上做互動功能時，其實就是生成一個json後利用request上傳到網站，使其做出相對應的行為。<br>而我們這邊主要用到的是將資料以json的方式儲存，之後再利用python的json套件，將其載入後，轉成dict型態，就可以方便我們加工處理了。</p>
<hr>
<h3 id="JSON的讀寫"><a href="#JSON的讀寫" class="headerlink" title="JSON的讀寫"></a>JSON的讀寫</h3><p>python有內建json讀寫的套件，但使用前要先import<br>主要是透過將json轉換成python的dictionary後進行操作再寫回去達成讀寫的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br></pre></td></tr></table></figure>

<p>主要會用到這幾種方法:</p>
<ul>
<li>json.load() : 將json檔案轉換成dictionary  </li>
<li>json.dump() : 將dictionary轉換成json檔案</li>
<li>json.loads() : 將字串轉換成python的dictionary</li>
<li>json.dumps() : 將python的dictionary轉換成字串</li>
</ul>
<p>而json裡的字串和陣列之類的型態也都會換成python自己的型態</p>
<hr>
<p>舉例來說，有個叫ex.json的json檔長得像下面這樣:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;	: &quot;mrrt&quot;, </span><br><span class="line">	&quot;score&quot;	: 80</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果今天想要透過同個資料夾的python檔案將其中的score改成100，拿load&#x2F;dump會這樣寫:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">with open (&#x27;ex.json&#x27;, &#x27;r&#x27;, encoding=&#x27;utf8&#x27;) as i:</span><br><span class="line">	jData = json.load(i)        #讀取json的資料並轉換成dictionary</span><br><span class="line"></span><br><span class="line">jData[&#x27;score&#x27;] = 100</span><br><span class="line"></span><br><span class="line">with open (&#x27;ex.json&#x27;, &#x27;w&#x27;) as i:</span><br><span class="line">	json.dump(jData, i)   #將dictionary轉換成json檔並寫入原本的檔案</span><br></pre></td></tr></table></figure>
<p>跑完後json檔就會變這樣<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-JSON/20152706aTZbLcqqi6.png"></p>
<hr>
<p>以loads&#x2F;dumps的話就會長得像下面這樣:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">with open (&#x27;ex.json&#x27;, &#x27;r&#x27;) as i:</span><br><span class="line">	t = i.read()        	#以str格式讀取json的資料</span><br><span class="line">	jData = json.loads(t)	#將str轉換成dictionary</span><br><span class="line"></span><br><span class="line">jData[&#x27;score&#x27;] = 100</span><br><span class="line"> </span><br><span class="line">with open (&#x27;ex.json&#x27;, &#x27;w&#x27;) as i:</span><br><span class="line">	i.write(json.dumps(jData))   #將dictionary轉換成符合json格式的字串並寫入原本的檔案 </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程式</category>
        <category>爬蟲</category>
      </categories>
      <tags>
        <tag>爬蟲</tag>
        <tag>程式</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬蟲基礎入門-Selenium</title>
    <url>/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/</url>
    <content><![CDATA[<h3 id="Selenium前置設定"><a href="#Selenium前置設定" class="headerlink" title="Selenium前置設定"></a>Selenium前置設定</h3><p>首先如果要先使用selenium，我們要先下載webdriver在資料夾中給予selenium使用。<br><a href="http://">https://chromedriver.chromium.org/downloads</a><br>上述網址即為chrome的webdriver下載地點。<br>下載好webdriver後我們就可以把他的exe檔丟到code的資料夾中了，就像這樣。</p>
<span id="more"></span>
<p><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/20152706vGDAntGabq.png"></p>
<p>接著我們就可以準備import了。<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/20152706yg28xxCq3g.png"><br>像這樣，其中webdriver就是引入我們剛剛載的webdriver，<br>Options則是selenium針對不同webdriver所納入的不同設定，<br>WebDriverWait跟EC則是在讓瀏覽器等待時會用到，像是我們可能會需要等到某網頁元素完整載入後才繼續程式，否則可能就會出錯，<br>最後By則是selenium中的內部語法，像是這樣，<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/20152706nZU06VhtHp.png"><br>這就表示著find_element這個函式將用XPath的方式定位元素。</p>
<h3 id="Selenium的指令使用"><a href="#Selenium的指令使用" class="headerlink" title="Selenium的指令使用"></a>Selenium的指令使用</h3><p><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/01.png"><br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/02.png"><br>首先我們先如上圖，套入webdriver的設定，讓程式載入我們先前載的chrome webdriver，接著再讓他導到我們想要的網址，這邊以youtube作範例。如果成功的話應該會如下圖這樣。<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/03.png"><br>阿記得開完網址後要time.sleep()一下，才不會直接跳掉。<br>其實在之後我們對selenium操控時，也必須要定時的time.sleep()或者是利用別的方法讓程式暫停，否則就會產生網頁還沒完全載入，我們就要找到他的元素等等的尷尬事情。</p>
<p>開完網頁後，就來介紹第一個函式，find_element<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/04.png"><br>find_element可以讓selenium定位到特定網頁元素，這邊的例子就是yt的搜尋欄。<br>其實selenium可以透過非常多方式定位，像是html碼裡的id、name等等，或者是class、css等其他方法，那麼我們這邊就用xpath這種定位方式，較為直接準確。但其實這邊範例比較不好的一點是xpath採用了絕對位置來定位，事實上，我們可以利用xpath的相對位置來達到簡潔、準確、可變動的性質，則之後在提及xpath時會在講解。</p>
<p>再來，既然我們定位到了網頁元素，則我們就要發揮selenium的強項了，就是模擬使用者對網頁的互動，這邊我們透過下圖講解兩個例子。<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/05.png"><br>這邊我們的目標是要進去yt，蒐集不同關鍵字搜尋後的影片，因此我們先建立一個list做作search_keys，裡面有著我們之後要輸入進搜尋欄的搜尋關鍵字。<br>則首先是element.send_keys()，我們先定位到搜尋欄位置後，將其命名為search_box，則search_box.send_keys()就能讓我們輸入關鍵字進去。<br>再來就是element.click()，在輸入進去後，我們還要再定位到yt網頁的搜尋按鈕上，在這裡，我們將其命名為search_box，則search_box.click()就能讓selenium模擬使用者對著搜尋按鈕按下滑鼠左鍵的這個動作。<br>就像這樣<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/06.png"><br>其實只要有這基本的動作，我們就能讓selenium動起來了，就像真人一樣互動，當然selenium還有更多的功能，像是WebDriverWait等等的功能，但這邊就不多做贅述了，我們明天會在講使用selenium常遇到的問題，其實很多都跟網頁載入時間有關。</p>
<p>喔對了，突然想到的小補充，上圖的範例其實就是之後其中一個專題內容，目標正是要讓selenium幫我們整理出想要的影片並輸出到discord上，因此也可以預見之後的專題應該會出現很多vt剪輯。<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/07.png"></p>
<h3 id="Selenium的常見Bug"><a href="#Selenium的常見Bug" class="headerlink" title="Selenium的常見Bug"></a>Selenium的常見Bug</h3><p>首先，第一個是版本問題，這其實是我前天在挖之前的程式出來跑時才發現的問題，<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/01-1.png"><br>這問題基本上是driver跟瀏覽器版本不支援，最簡單只要重新下載對應版本的webdriver就好。</p>
<p>接著是這個，<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/02-1.png"><br>這代表著selenium無法找到你所指定的元素，一般來說，如果不是你定位位置錯誤，<br>八成就是網頁還沒有完整載入，就使selemium搜尋元素。<br>此時，我們可以試著使用簡單的方法，time.sleep()，使程式整體暫停n秒，也可以配合try except使用。<br>當然，selenium針對這個問題也有開發相關函式，首先是顯式等待，<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/03-1.png"><br>在這邊的意思是，我們針對所給予的元素，等待10秒，每0.2秒檢查是否出現，如果出現了就繼續，<br>如果10秒內還沒出現則報錯。<br>另外一種則是隱式等待，<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-Selenium/04-1.png"><br>相對於顯式等待是針對個別元素是否生成，隱式等待則是針對整個頁面，以上圖為例，這邊就是讓整個程式暫停，<br>給予瀏覽器10秒的時間，如果10秒內”整個頁面都已經生成完成”(講得直白一點其實就是我們頁面左上角的圈圈不再轉動)，則繼續程式運行，如果10內還沒載完，則報錯，因此可以看的出來，相對於顯式等待，隱式等待跟強制等待可能會要花費更久的時間。</p>
]]></content>
      <categories>
        <category>程式</category>
        <category>爬蟲</category>
      </categories>
      <tags>
        <tag>爬蟲</tag>
        <tag>程式</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬蟲基礎入門-XPath</title>
    <url>/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-XPath/</url>
    <content><![CDATA[<p>我們在selenium時有講到幾個指令像是find_element_by的指令，<br>但如果我們的html沒有class或是id等節點的話，其實對我們爬蟲有點不太友善，<br>所以今天我們會教xpath的搜尋方法</p>
<span id="more"></span>

<h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3><p>XML Path簡稱XPath，是一種可以用來確定一個東西在XML&#x2F;HTML檔案中的位置的語言&#x2F;工具<br>可以將一個HTML看成是一棵樹，或是更生活化一點，利用樹狀結構的目錄資料夾<br>像是檔案開頭的<code>&lt;html&gt;</code>包含了整個文件，而這個節點就是整個html的根節點<br>或者是如<code>&lt;head&gt;</code>或是<code>&lt;body&gt;</code>在html下一層，而這兩個節點就是html的子節點，<br>相反地，<code>&lt;html&gt;</code>也是<code>&lt;head&gt;</code>或是<code>&lt;body&gt;</code>的父節點<br>此外，<code>&lt;html&gt;</code>與<code>&lt;head&gt;</code>相互是兄弟節點<br>樹中有許多的節點代表不同元素，而我們就可以使用XPath去查詢這些節點</p>
<h2 id="在XPath中，我們有兩種方式去表現一個節點的位置-絕對路徑-絕對路徑以-來代表，需要從html的根節點開始寫完整的路徑到目標的節點-如-html-1-body-1-div-3-div-1-div-1-div-1-div-2-div-3-div-1-h2-1-，是我們在Day13網頁中標題的絕對路徑-相對路徑-相對路徑以-來代表-如-h2-contains-text-’Day13、Selenium指令使用’-來代表上面相同上面絕對路徑的相對路徑"><a href="#在XPath中，我們有兩種方式去表現一個節點的位置-絕對路徑-絕對路徑以-來代表，需要從html的根節點開始寫完整的路徑到目標的節點-如-html-1-body-1-div-3-div-1-div-1-div-1-div-2-div-3-div-1-h2-1-，是我們在Day13網頁中標題的絕對路徑-相對路徑-相對路徑以-來代表-如-h2-contains-text-’Day13、Selenium指令使用’-來代表上面相同上面絕對路徑的相對路徑" class="headerlink" title="在XPath中，我們有兩種方式去表現一個節點的位置- 絕對路徑    絕對路徑以 &#x2F; 來代表，需要從html的根節點開始寫完整的路徑到目標的節點    如:&#x2F;html[1]&#x2F;body[1]&#x2F;div[3]&#x2F;div[1]&#x2F;div[1]&#x2F;div[1]&#x2F;div[2]&#x2F;div[3]&#x2F;div[1]&#x2F;h2[1]，是我們在Day13網頁中標題的絕對路徑- 相對路徑    相對路徑以 &#x2F;&#x2F; 來代表    如:&#x2F;&#x2F;h2[contains(text(),’Day13、Selenium指令使用’)]來代表上面相同上面絕對路徑的相對路徑"></a>在XPath中，我們有兩種方式去表現一個節點的位置<br>- <strong>絕對路徑</strong><br>    絕對路徑以 <strong>&#x2F;</strong> 來代表，需要從html的根節點開始寫完整的路徑到目標的節點<br>    如:&#x2F;html[1]&#x2F;body[1]&#x2F;div[3]&#x2F;div[1]&#x2F;div[1]&#x2F;div[1]&#x2F;div[2]&#x2F;div[3]&#x2F;div[1]&#x2F;h2[1]，是我們在Day13網頁中標題的絕對路徑<br>- <strong>相對路徑</strong><br>    相對路徑以 <strong>&#x2F;&#x2F;</strong> 來代表<br>    如:&#x2F;&#x2F;h2[contains(text(),’Day13、Selenium指令使用’)]來代表上面相同上面絕對路徑的相對路徑</h2><h3 id="find-element-by-xpath"><a href="#find-element-by-xpath" class="headerlink" title="find_element_by_xpath()"></a>find_element_by_xpath()</h3><p>利用上面絕對路徑或是相對路徑的方法，直接塞進function就好了，如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">node = chrome.find_element_by_path(<span class="string">&#x27;/html[1]/body[1]/div[3]/div[1]/div[1]/div[1]/div[2]/div[3]/div[1]/h2[1]&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>常常在html中會看到在同個檔案不同個子樹下有相同的節點命名，當使用xpath的相對路徑時可能會有問題<br>這個時候可以透過index索引去找是哪一個節點，如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">node = chrome.find_element_by_path(<span class="string">&#x27;//p[0]&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>或是利用attribute屬性去標註說我們現在要的是哪一個，如:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&#x27;title&#x27;</span>&gt;</span>I&#x27;m title<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">node = chrome.find_element_by_path(<span class="string">&quot;//p[@class=&#x27;title&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>還有一些神奇的指令像是contains()，可以找出包含字串的節點，如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">node = chrome.find_element_by_path(<span class="string">&quot;//p[contains(text(), &#x27;title&#x27;)]&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>上面講了xpath的語法，但是其實你知道只需要有html樹狀的概念就好了嗎?<br>俗話說的好，不要重複造輪子，今天就介紹一個好用的工具可以自動產生xpath</p>
<h3 id="ChroPath"><a href="#ChroPath" class="headerlink" title="ChroPath"></a>ChroPath</h3><p>ChroPath是一個Chrome的插件，可以在chrome的應用程式商店找到他<br>它是一個協助我們在chrome中定位想要的元素的插件<br>假如你想針對一個網頁的按鈕找出它的xpath去進行selenium控制的話，可以右鍵找到「檢查」的地方後點下去，會進入F12開發者模式，同時F12的html畫面也會同步到一樣的程式片段<br>在此時，我們在右邊開發者模式視窗的地方中間有一排選擇子視窗的地方去找一個叫做ChroPath的地方點開來<br>點開之後，插件就會告訴你路徑的絕對位置或相對位置囉!<br><img data-src="/%E7%88%AC%E8%9F%B2%E5%9F%BA%E7%A4%8E%E5%85%A5%E9%96%80-XPath/20152706sgIGrAITNx.png"></p>
<p>XPath就是這麼簡單!</p>
]]></content>
      <categories>
        <category>程式</category>
        <category>爬蟲</category>
      </categories>
      <tags>
        <tag>爬蟲</tag>
        <tag>程式</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>地形考察報告</title>
    <url>/%E5%9C%B0%E5%BD%A2%E8%80%83%E5%AF%9F%E5%A0%B1%E5%91%8A/</url>
    <content><![CDATA[<p>國立台北教育大學<br>地形考察報告<br>結報</p>
<span id="more"></span>

<div class="pdfobject-container" data-target="NTUE-Geo.pdf" data-height="500px"></div>]]></content>
      <categories>
        <category>結報</category>
        <category>國北教自</category>
      </categories>
      <tags>
        <tag>結報</tag>
      </tags>
  </entry>
  <entry>
    <title>越式涼拌</title>
    <url>/%E8%B6%8A%E5%BC%8F%E6%B6%BC%E6%8B%8C/</url>
    <content><![CDATA[<h3 id="醬料"><a href="#醬料" class="headerlink" title="醬料"></a>醬料</h3><p>1.蒜頭、辣椒切碎<br>2.加入糖一匙<br>3.魚露兩匙<br>4.檸檬汁一顆的量<span id="more"></span><br>5.白胡椒粉一小匙<br>6.加入兩匙水、拌勻</p>
<p>再切個青木瓜絲、紅蘿蔔絲、小黃瓜絲丟進去拌一拌，灑上一把鹹花生就完成了。</p>
<div class="pdfobject-container" data-target="pdf/110033210.pdf" data-height="500px"></div>

<p><em><strong>好吃到Xin chào&trade;</strong></em><br><strong>筆者：蔡銘揚</strong></p>
]]></content>
      <categories>
        <category>飲食</category>
        <category>食譜</category>
      </categories>
      <tags>
        <tag>自製</tag>
        <tag>食譜</tag>
      </tags>
  </entry>
  <entry>
    <title>舒服的暑假</title>
    <url>/%E8%88%92%E6%9C%8D%E7%9A%84%E6%9A%91%E5%81%87/</url>
    <content><![CDATA[<p>最近放暑假，最舒服的就是中午起床弄個午餐，配杯highball搭著netflix或VT。<br>嗨波其實就是簡單的威士忌加氣泡水，而清爽的口感在夏日午後絕對是最好的享受。</p>
<h3 id="製作方法"><a href="#製作方法" class="headerlink" title="製作方法"></a>製作方法</h3><p>首先在杯中加入大冰塊，接著根據你的錢包厚度還有你的心情加入45~60ml的威士忌。 <span id="more"></span><br><img data-src="/%E8%88%92%E6%9C%8D%E7%9A%84%E6%9A%91%E5%81%87/01.jpg"></p>
<p>接著用吧叉匙攪拌10到15圈，冷卻杯內的威士忌。<br><img data-src="/%E8%88%92%E6%9C%8D%E7%9A%84%E6%9A%91%E5%81%87/02.jpg"></p>
<p>之後再倒入氣泡水至8分滿，注意在倒入氣泡水時可以傾斜杯口倒入，而不要直接快速猛烈地把氣泡水倒在冰塊上，避免氣泡散失。<br><img data-src="/%E8%88%92%E6%9C%8D%E7%9A%84%E6%9A%91%E5%81%87/03.jpg"></p>
<p>最後根據口味，擠上一片檸檬再丟進杯內，給予清爽的香氣跟層次。<br><img data-src="/%E8%88%92%E6%9C%8D%E7%9A%84%E6%9A%91%E5%81%87/04.jpg"></p>
<hr>
<p>把你的嗨波還有炒麵放到電腦前，配著自己喜歡的音樂、劇或VT，嗨波剛入口時帶有舒服的氣泡感，清涼的氣泡將威士忌的麥香與水果花香跟著帶了上來，保留威士忌的香味時也減去了過多的酒精感，直接丟入杯中的檸檬可以讓嗅覺上增添清香，入口時也可以多出微微的香氣跟層次，配上透明的老冰更是視覺上的絕配。<br><img data-src="/%E8%88%92%E6%9C%8D%E7%9A%84%E6%9A%91%E5%81%87/05.jpg"><br><img data-src="/%E8%88%92%E6%9C%8D%E7%9A%84%E6%9A%91%E5%81%87/06.jpg"></p>
<hr>
<p>上面可以發現嗨波真的是非常簡單的一杯酒，除了不用事先準備糖漿和檸檬汁外，也不需要shake和stir等技術，不過在調製時仍有一些小技巧跟事先準備的方法，而這些細節可以大幅改善你的品飲體驗跟準備工序，但這就留到下次再補充好了。</p>
]]></content>
      <categories>
        <category>飲食</category>
        <category>酒</category>
      </categories>
      <tags>
        <tag>調酒</tag>
        <tag>酒譜</tag>
        <tag>自製</tag>
      </tags>
  </entry>
  <entry>
    <title>熱流實驗 風洞與流視 結報</title>
    <url>/%E7%86%B1%E6%B5%81%E5%AF%A6%E9%A9%97-%E9%A2%A8%E6%B4%9E%E8%88%87%E6%B5%81%E8%A6%96-%E7%B5%90%E5%A0%B1/</url>
    <content><![CDATA[<p>國立清華大學動力機械工程學系<br>熱流實驗-風洞與流視<br>結報</p>
<span id="more"></span>

<div class="pdfobject-container" data-target="110033210.pdf" data-height="500px"></div>

]]></content>
      <categories>
        <category>結報</category>
        <category>清大動機</category>
      </categories>
      <tags>
        <tag>結報</tag>
      </tags>
  </entry>
</search>
